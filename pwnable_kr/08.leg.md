# Pwnable.kr leg

本题可以给帮助我们进行 ARM 汇编初探

## 前言
要有`x86`和`i386`汇编基础，主要就是谈一下`ARM`汇编一些很"奇怪"的特点。

## 状态
`ARM`汇编有两种状态: `arm` && `thumb`，前者状态下字节长度为4，后者状态下字节长度为2。因此不同状态下同一个指令会有不同动作。
- PC存储有区别
    `arm`模式下`PC = 当前地址 + 8`，`thumb`模式下`PC = 当前指令地址 + 4`。

- 跳转指令有区别
    这个下面会详细将跳转指令，反正时刻注意`ARM`汇编他要根据不同状态来做不同操作


## 跳转指令(B，对应`jmp`)

### `BL offset`
这个`offset`是一个立即数，直接偏移地址为这个立即数的地方执行代码，返回地址会保存在`lr`中！

### `BX reg`
我起初以为是比如`bx r0`，那就跳到`[r0]`处。不过有两点要注意的地方！
第一点，跳转地址并不是`[r0]`，而是`[r0] & 0xFFFE`，也就是**最后一位要先置0，再去跳转到对应位置**。
第二点，**这个命令可能会改变寄存器状态！！**
第一点可以看到，最后一位没有用，所以用来作标志位。如果是0，那么状态变为`arm`；如果是1，那么状态变为`thumb`。

### `BX lr`
为什么单独将这个呢，明明不就是上面的一个特例吗。的确如此，不过我想说的是，`ARM`是严格指令对齐，所以地址一定是4的倍数，所以很显然，当`bx lr`执行完成后，一定会变成`arm`状态！
